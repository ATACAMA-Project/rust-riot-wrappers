//! https://api.riot-os.org/credman_8h_source.html
//!
//! Authors: Henri Waller <henri@uni-bremen.de>, Lukas Terlau <terlau@uni-bremen.de>

use core::ptr;
use riot_sys::libc::c_void;
use riot_sys::size_t;

/// Enum to wrap status returns
/// CredmanStatusUnknown is an addition incase of a new and/or unimplemented status
#[derive(Debug)]
#[non_exhaustive]
pub enum CredmanStatus {
    CredmanOK,
    CredmanExist,
    CredmanNoSpace,
    CredmanNotFound,
    CredmanInvalid,
    CredmanTypeUnknown,
    CredmanError,
    CredmanStatusUnknown,
}

/// Implementation for CredmanType enum
/// provides function to convert a status from an 'i32' to its CredmanType equivalent
impl CredmanStatus {
    /// Converts the given `i32` into the matching CredmanStatus representation
    fn from_value(n: i32) -> Self {
        match n {
            0 => Self::CredmanOK,
            -1 => Self::CredmanExist,
            -2 => Self::CredmanNoSpace,
            -3 => Self::CredmanNotFound,
            -4 => Self::CredmanInvalid,
            -5 => Self::CredmanTypeUnknown,
            -6 => Self::CredmanError,
            _ => Self::CredmanStatusUnknown,
        }
    }
}

/// Enum equivalent to riotsys::credman_type_t
#[derive(Debug)]
#[non_exhaustive]
pub enum CredmanType {
    CredmanTypeEmpty,
    CredmanTypePSK,
    CredmanTypeECDSA,
}

/// Implementation for CredmanType enum
/// provides function to convert CredmanType to its autogenerated riotsys equivalent
impl CredmanType {
    /// takes the CredmanType its called form and converts it to its autogenerated riotsys credman_type_t equivalent
    fn to_c(self) -> riot_sys::credman_type_t {
        match self {
            Self::CredmanTypeEmpty => riot_sys::credman_type_t_CREDMAN_TYPE_EMPTY,
            Self::CredmanTypePSK => riot_sys::credman_type_t_CREDMAN_TYPE_PSK,
            Self::CredmanTypeECDSA => riot_sys::credman_type_t_CREDMAN_TYPE_ECDSA,
        }
    }
}

/// Reference to a riotsys credman_credential_t
/// used by the get function to wrap the riotsys::credman_credential_t struct
pub struct CredentialRef {
    pub credential: riot_sys::credman_credential_t,
}

/// unsigned 16 bit number. needed for every new credential as an identifier
type CredmanTag = u16;

/// Enum for the two possible credential types
/// passes the scope to manage the lifetime and ensure everything's not deleted before the struct goes out of scope
pub enum Params<'a> {
    Psk(PskParams<'a>),
    Ecdsa(EcdsaParams<'a>),
}

/// struct to store all relevant data for the usage of a psk key
/// passes the scope to manage the lifetime and ensure everything's not deleted before the struct goes out of scope
pub struct PskParams<'a> {
    pub key: &'a [u8],
    pub id: &'a [u8],
    pub hint: &'a [u8],
}

/// struct to store all relevant data for a ecdsa pub key
/// passes the scope to manage the lifetime and ensure everything's not deleted before the struct goes out of scope
pub struct EcdsaPublicKey<'a> {
    pub x: &'a [u8],
    pub y: &'a [u8],
}

/// struct to store all relevant data for the usage of a ecdsa key
/// passes the scope to manage the lifetime and ensure everything's not deleted before the struct goes out of scope
pub struct EcdsaParams<'a> {
    pub private_key: &'a [u8],
    pub public_key: EcdsaPublicKey<'a>,
    client_keys: &'a [riot_sys::ecdsa_public_key_t],
}

/// implementation for EcdsaParams
/// provides a function to initialize ecdsa key set
impl<'a> EcdsaParams<'a> {
    /// intializes private key, public key and client keys for using ecdsa during communication.
    /// returns the params wrapped in a struct
    ///  
    /// # Arguments
    ///
    /// * `pivate_key` - private keys of the EcdsaParams
    /// * `public_key` - public keys of the EcdsaParams
    /// * `client_keys` - client keys of the EcdsaParams
    pub fn new<const EC_CLIENT_KEYS_NUM: usize>(
        private_key: &'a [u8],
        public_key: EcdsaPublicKey<'a>,
        client_keys: &'a EcdsaClientKeys<EC_CLIENT_KEYS_NUM>,
    ) -> Self {
        EcdsaParams {
            private_key,
            public_key,
            client_keys: &client_keys.client_keys_c,
        }
    }
}

/// stores the client keys
pub struct EcdsaClientKeys<const EC_CLIENT_KEYS_NUM: usize> {
    client_keys_c: [riot_sys::ecdsa_public_key_t; EC_CLIENT_KEYS_NUM],
}

/// Implemention for EcdsaClientKeys
/// providing function for initialization
impl<const EC_CLIENT_KEYS_NUM: usize> EcdsaClientKeys<EC_CLIENT_KEYS_NUM> {
    /// takes array of ecdsa public keys and returns a EcdsaClientKeys
    ///
    /// # Arguments
    ///
    /// * `client_keys` -  array of ecdsa public keys
    pub fn new(client_keys: &[EcdsaPublicKey]) -> Self {
        let mut keys = EcdsaClientKeys {
            client_keys_c: [riot_sys::ecdsa_public_key_t {
                x: ptr::null(),
                y: ptr::null(),
            }; EC_CLIENT_KEYS_NUM],
        };
        for (i, key) in client_keys.iter().enumerate() {
            keys.client_keys_c[i] = riot_sys::ecdsa_public_key_t {
                x: key.x.as_ptr() as *const c_void,
                y: key.y.as_ptr() as *const c_void,
            };
        }
        keys
    }
}


/// struct storing riot_sys::credman_credential_t and a Params which includes the relevant data of the credential
pub struct Credential<'a> {
    credential: riot_sys::credman_credential_t,
    params: Params<'a>,
}

/// Implementation providing an initialization for psk as well as ecdsa credentials
impl<'a> Credential<'a> {
    /// Function initializes psk credentials
    ///
    /// # Arguments
    ///
    /// * `tag` - unique tag/identification of the credential
    /// * `psk` - psk params of the credential
    ///
    /// # Example
    ///
    /// let psk_key = "hallo123";
    /// let psk_id = "Alice";
    /// let psk_hint = "Hint";
    ///
    ///
    /// let psk = PskParams {
    ///     key: PSK_KEY.as_bytes(),
    ///     id: PSK_ID.as_bytes(),
    ///     hint: PSK_HINT.as_bytes(),
    /// };
    /// let credential = Credential::new_psk(42, psk);
    ///
    pub fn new_psk(tag: CredmanTag, psk: PskParams<'a>) -> Self {
        let psk_c = riot_sys::psk_params_t {
            key: riot_sys::credman_buffer_t {
                s: psk.key.as_ptr() as *const c_void,
                len: psk.key.len() as size_t,
            },
            id: riot_sys::credman_buffer_t {
                s: psk.id.as_ptr() as *const c_void,
                len: psk.id.len() as size_t,
            },
            hint: riot_sys::credman_buffer_t {
                s: psk.hint.as_ptr() as *const c_void,
                len: psk.hint.len() as size_t,
            },
        };
        Credential {
            credential: riot_sys::credman_credential_t {
                type_: riot_sys::credman_type_t_CREDMAN_TYPE_PSK,
                tag,
                params: riot_sys::credman_credential_t__bindgen_ty_1 { psk: psk_c },
            },
            params: Params::Psk(psk),
        }
    }

    /// Function initializes ecdsa credentials
    ///
    /// # Arguments
    ///
    /// * `tag` - unique tag/identification of the credential
    /// * `ecdsa` - ecdsa params of the credential
    ///
    /// # Example
    ///
    /// let ecdsa_priv_key: [u8; 32] = [ ***KEY*** ];
    /// let ecdsa_pub_key_x: [u8; 32] = [ ***KEY*** ];
    /// let ecdsa_pub_key_y: [u8; 32] = [ ***KEY*** ];
    ///
    /// let public_key = EcdsaPublicKey {
    ///     x: &ecdsa_pub_key_x,
    ///     y: &ecdsa_pub_key_y,
    /// };
    /// let client_keys_a: [EcdsaPublicKey; 1] = [EcdsaPublicKey {
    ///     x: &ecdsa_pub_key_x,
    ///     y: &ecdsa_pub_key_y,
    /// }];
    /// let client_keys: EcdsaClientKeys<1> = EcdsaClientKeys::new(&client_keys_a);
    /// let ecdsa = EcdsaParams::new(&ecdsa_priv_key, public_key, &client_keys);
    /// let credential = Credential::new_ecdsa(11, ecdsa);
    ///
    pub fn new_ecdsa(tag: CredmanTag, ecdsa: EcdsaParams<'a>) -> Self {
        let ecdsa_c = riot_sys::ecdsa_params_t {
            private_key: ecdsa.private_key.as_ptr() as *const c_void,
            public_key: riot_sys::ecdsa_public_key_t {
                x: ecdsa.public_key.x.as_ptr() as *const c_void,
                y: ecdsa.public_key.y.as_ptr() as *const c_void,
            },
            client_keys: ecdsa.client_keys.as_ptr() as *mut _, //Is assumed not to be mutated during the runtime?
            client_keys_size: ecdsa.client_keys.len() as size_t,
        };

        Credential {
            credential: riot_sys::credman_credential_t {
                type_: riot_sys::credman_type_t_CREDMAN_TYPE_ECDSA,
                tag,
                params: riot_sys::credman_credential_t__bindgen_ty_1 { ecdsa: ecdsa_c },
            },
            params: Params::Ecdsa(ecdsa),
        }
    }
}

impl<'a> Drop for Credential<'a> {
    /// the `drop` method tries to remove the credman_credential_t form the credential pool when the corresponding `Credential` leaves the scope
    fn drop(&mut self) {
        unsafe {
            riot_sys::credman_delete(self.credential.tag, self.credential.type_);
        }
    }
}


/// tries to add credential to the credential pool
///
/// returns status it finished with as a `CredmanStatus`
///
/// # Arguments
///
/// * `credential` - Credential to add
pub fn credman_add(credential: &Credential) -> CredmanStatus {
    let res = unsafe {
        riot_sys::credman_add(&credential.credential as *const riot_sys::credman_credential_t)
    };
    CredmanStatus::from_value(res)
}

/// tries to get a credential from the credential pool
///
/// on Success returns the CredentialRef
/// on Error returns status it finished with as a `CredmanStatus`
///
/// # Arguments
///
/// * `tag` - unique tag/identification of the credential to get
/// * `typ` - type of the credential to get
pub unsafe fn credman_get(
    tag: CredmanTag,
    typ: CredmanType,
) -> Result<CredentialRef, CredmanStatus> {
    let mut cred: riot_sys::credman_credential_t = Default::default();
    let res = unsafe {
        riot_sys::credman_get(
            &mut cred as *mut riot_sys::credman_credential_t,
            tag,
            CredmanType::to_c(typ),
        )
    };
    match CredmanStatus::from_value(res) {
        CredmanStatus::CredmanOK => Ok(CredentialRef { credential: cred }),
        status => Err(status),
    }
}

/// tries to delete a credential form the credential pool.
/// does nothing if `CredmanTag` and `CredmanType` is not found
///  
/// # Arguments
///
/// * `tag` - unique tag/identification of the credential to delete
/// * `typ` - type of the credential to delet
pub fn credman_delete(tag: CredmanTag, typ: CredmanType) {
    unsafe { riot_sys::credman_delete(tag, CredmanType::to_c(typ)) };
}

/// returns the number of the credentials currently stored in the credential pool
/// maximum number of allowed credentials is defined by CONFIG_CREDMAN_MAX_CREDENTIALS
pub fn credman_get_used_count() -> u32 {
    unsafe { riot_sys::credman_get_used_count() as u32 }
}
